// src/generator.ts
import fs from "fs";
import fsPromises from "fs/promises";
import path from "path";
/**
 * Human-friendly section name from first path segment.
 * "blog" -> "Blog", "forgot-password" -> "Forgot Password"
 */
function formatSectionName(segment) {
    if (!segment)
        return "Home";
    const replaced = segment.replace(/[-_]/g, " ");
    return replaced.charAt(0).toUpperCase() + replaced.slice(1);
}
/**
 * Score a PageMeta for ordering (higher = more representative).
 * Heuristic:
 *  - explicit page score field (if present)
 *  - presence of h1
 *  - presence of description
 *  - shallower path (fewer segments)
 *  - shorter title preferred
 */
function pageScore(meta) {
    let s = 0;
    if (typeof meta.score === "number")
        s += meta.score * 10;
    if (meta.h1)
        s += 10;
    if (meta.description)
        s += 5;
    try {
        const p = new URL(meta.url).pathname.split("/").filter(Boolean).length;
        s += Math.max(0, 6 - p); // prefer shallower pages
    }
    catch {
        // ignore
    }
    if (meta.title)
        s += Math.max(0, 40 - Math.floor((meta.title.length || 0) / 2));
    return s;
}
/**
 * Group metas by top-level section (first path segment).
 * Root/home pages go under key "".
 */
function groupByTopSection(metas) {
    const sections = {};
    for (const m of metas) {
        try {
            const u = new URL(m.url);
            const parts = u.pathname.split("/").filter(Boolean);
            const key = parts.length > 0 ? parts[0] : ""; // "" means Home/root
            if (!sections[key])
                sections[key] = [];
            sections[key].push(m);
        }
        catch {
            // If URL parsing fails put under "_other"
            if (!sections["_other"])
                sections["_other"] = [];
            sections["_other"].push(m);
        }
    }
    return sections;
}
/**
 * Order sections:
 *  - Home (key === "") first
 *  - then by descending number of items (large sections first)
 *  - tie-break alphabetical
 */
function orderSectionKeys(keys, sectionsMap) {
    return keys
        .slice()
        .sort((a, b) => {
        if (a === "")
            return -1;
        if (b === "")
            return 1;
        const na = sectionsMap[a]?.length ?? 0;
        const nb = sectionsMap[b]?.length ?? 0;
        if (na !== nb)
            return nb - na; // larger first
        return a.localeCompare(b);
    });
}
/**
 * Within a section:
 *  - place canonical listing page (exact path /section or /section/) first if present
 *  - then sort remaining by pageScore desc, then title length asc
 *
 * This is CPU-bound (sorting), but sections are independent, so we parallelize per-section.
 */
function orderSectionItemsSync(sectionKey, items) {
    // find canonical listing page
    const listingIdx = items.findIndex((m) => {
        try {
            const u = new URL(m.url);
            const parts = u.pathname.split("/").filter(Boolean);
            // sectionKey == "" -> root listing page ("/")
            if (sectionKey === "")
                return parts.length === 0 || (parts.length === 1 && parts[0] === "index");
            return parts.length === 1 && parts[0] === sectionKey;
        }
        catch {
            return false;
        }
    });
    const itemsCopy = items.slice();
    let listing;
    if (listingIdx >= 0) {
        listing = itemsCopy.splice(listingIdx, 1)[0];
    }
    itemsCopy.sort((a, b) => {
        const sa = pageScore(a);
        const sb = pageScore(b);
        if (sb !== sa)
            return sb - sa;
        const ta = (a.title || "").length;
        const tb = (b.title || "").length;
        return ta - tb;
    });
    const ordered = [];
    if (listing)
        ordered.push(listing);
    ordered.push(...itemsCopy);
    return ordered;
}
/**
 * Simple async pool to process an array with concurrency limit.
 */
async function asyncPool(poolLimit, array, iteratorFn) {
    const ret = [];
    const executing = [];
    let i = 0;
    async function enqueueNext() {
        if (i >= array.length)
            return;
        const currentIndex = i++;
        const p = Promise.resolve()
            .then(() => iteratorFn(array[currentIndex], currentIndex))
            .then((res) => {
            ret[currentIndex] = res;
        })
            .catch((err) => {
            // Surface errors to caller â€” push as rejection
            throw err;
        });
        const e = p.then(() => {
            // remove finished promise from executing (not strictly necessary)
        });
        executing.push(e);
        if (executing.length >= poolLimit) {
            await Promise.race(executing);
            // remove settled ones
            for (let j = executing.length - 1; j >= 0; j--) {
                // can't reliably check settled promises, but Promise.race above ensures at least one settled
                // we simply shift to keep array from growing in long runs
                executing.shift();
            }
        }
        return enqueueNext();
    }
    await enqueueNext();
    // wait for all to finish
    await Promise.all(executing).catch(() => {
        // let the actual iteratorFn throw to bubble up
    });
    return ret;
}
/**
 * Render the single llms.txt file in a streaming+concurrent manner.
 * Returns { shortTxt, shortPath } for backwards compatibility.
 */
export async function writeFiles(rootUrl, metas, opts) {
    const concurrency = Math.max(1, opts.concurrency ?? 4);
    const sections = groupByTopSection(metas);
    const keysOrdered = orderSectionKeys(Object.keys(sections), sections);
    // compute ordered items per section in parallel (bounded)
    // We'll produce an array of { key, orderedItems } that preserves keysOrdered indices.
    const work = keysOrdered.map((k) => ({ key: k, items: sections[k] || [] }));
    const results = await asyncPool(concurrency, work, async (entry) => {
        // heavy/synchronous sort happens inside orderSectionItemsSync
        const ordered = orderSectionItemsSync(entry.key, entry.items);
        return { key: entry.key, ordered };
    });
    // results is in same index order as `work`, but to be safe map by key
    const orderedMap = {};
    for (const r of results) {
        orderedMap[r.key] = r.ordered;
    }
    // Prepare output path + stream
    const outDir = opts.outputDir || process.cwd();
    const outPath = path.join(outDir, "llms.txt");
    await fsPromises.mkdir(outDir, { recursive: true });
    const ws = fs.createWriteStream(outPath, { encoding: "utf8", flags: "w" });
    // choose site title: prefer root/index title then first found title
    let siteTitle = "";
    if (sections[""]) {
        const rootTitle = sections[""].find((m) => m.title)?.title;
        if (rootTitle)
            siteTitle = rootTitle;
    }
    if (!siteTitle) {
        const anyTitle = metas.find((m) => m.title)?.title;
        siteTitle = anyTitle || new URL(rootUrl).hostname;
    }
    // choose site description: prefer root meta description, else best description
    let siteDesc = "";
    if (sections[""]) {
        const rootDesc = sections[""].find((m) => m.description)?.description;
        if (rootDesc)
            siteDesc = rootDesc;
    }
    if (!siteDesc) {
        const anyDesc = metas.find((m) => m.description)?.description;
        if (anyDesc)
            siteDesc = anyDesc;
    }
    // We'll build the text incrementally (append to array to return full string at end)
    const outParts = [];
    function pushLine(line = "") {
        outParts.push(line);
        ws.write(line + "\n");
    }
    // Header
    pushLine(`# ${siteTitle}`);
    if (siteDesc) {
        pushLine("");
        pushLine(`> ${siteDesc}`);
        pushLine("");
    }
    else {
        pushLine("");
    }
    // Sections (preserve keysOrdered)
    for (const key of keysOrdered) {
        const human = key === "" ? "Home" : formatSectionName(key);
        pushLine(`## ${human}`);
        const ordered = orderedMap[key] || [];
        for (const m of ordered) {
            const desc = m.description ? `: ${m.description}` : "";
            const title = m.title || m.url;
            pushLine(`- [${title}](${m.url})${desc}`);
        }
        pushLine("");
    }
    // finalize
    await new Promise((resolve, reject) => {
        ws.end(() => resolve());
        ws.on("error", (err) => reject(err));
    });
    const shortTxt = outParts.join("\n");
    return { shortTxt, shortPath: outPath };
}
